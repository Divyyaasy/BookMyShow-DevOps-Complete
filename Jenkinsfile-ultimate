pipeline {
    agent any
    
    tools {
        jdk 'jdk17'
        nodejs 'node23'
        sonarQubeScanner 'sonar-scanner'
    }
    
    environment {
        // AWS Configuration
        AWS_REGION = 'us-east-1'
        ECR_REPO = 'bookmyshow'
        EKS_CLUSTER = 'bookmyshow-eks'
        
        // Docker Configuration
        DOCKER_REGISTRY = 'your-account.dkr.ecr.${AWS_REGION}.amazonaws.com'
        DOCKER_IMAGE = '${DOCKER_REGISTRY}/${ECR_REPO}'
        DOCKER_TAG = "${BUILD_NUMBER}"
        
        // Application
        APP_NAME = 'bms'
        NAMESPACE = 'bookmyshow-prod'
    }
    
    stages {
        // STAGE 1: Code Checkout
        stage('Checkout Code') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: '*/main']],
                    extensions: [],
                    userRemoteConfigs: [[
                        url: 'https://github.com/staragile2016/Book-My-Show.git',
                        credentialsId: 'github-credentials'
                    ]]
                ])
                sh 'echo "Repository checked out successfully"'
                sh 'ls -la'
            }
        }
        
        // STAGE 2: Install Dependencies
        stage('Install Dependencies') {
            steps {
                dir('bookmyshow-app') {
                    sh 'npm install'
                    sh 'npm audit fix --force || true'
                }
            }
        }
        
        // STAGE 3: Code Quality Analysis
        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('sonar-server') {
                    dir('bookmyshow-app') {
                        sh '''
                        sonar-scanner \
                        -Dsonar.projectKey=BookMyShow \
                        -Dsonar.projectName="BookMyShow" \
                        -Dsonar.sources=src \
                        -Dsonar.host.url=${SONAR_HOST_URL} \
                        -Dsonar.login=${SONAR_AUTH_TOKEN}
                        '''
                    }
                }
            }
        }
        
        // STAGE 4: Build Application
        stage('Build Application') {
            steps {
                dir('bookmyshow-app') {
                    sh 'npm run build || echo "Build script not found, continuing..."'
                }
            }
        }
        
        // STAGE 5: Run Tests
        stage('Run Tests') {
            steps {
                dir('bookmyshow-app') {
                    sh 'npm test || echo "Tests not configured, continuing..."'
                }
            }
            post {
                always {
                    junit 'bookmyshow-app/test-results/**/*.xml'
                    publishHTML(target: [
                        reportName: 'Test Report',
                        reportDir: 'bookmyshow-app/coverage',
                        reportFiles: 'index.html',
                        keepAll: true
                    ])
                }
            }
        }
        
        // STAGE 6: Docker Build
        stage('Docker Build') {
            steps {
                script {
                    // Login to AWS ECR
                    sh '''
                        aws ecr get-login-password --region ${AWS_REGION} | \
                        docker login --username AWS --password-stdin ${DOCKER_REGISTRY}
                    '''
                    
                    // Build Docker image
                    dir('bookmyshow-app') {
                        sh """
                            docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .
                            docker build -t ${DOCKER_IMAGE}:latest .
                        """
                    }
                }
            }
        }
        
        // STAGE 7: Push to ECR
        stage('Push to ECR') {
            steps {
                script {
                    sh """
                        docker push ${DOCKER_IMAGE}:${DOCKER_TAG}
                        docker push ${DOCKER_IMAGE}:latest
                    """
                }
            }
        }
        
        // STAGE 8: Deploy to EKS (Development)
        stage('Deploy to EKS Dev') {
            steps {
                script {
                    // Update kubeconfig for EKS
                    sh """
                        aws eks update-kubeconfig \
                        --region ${AWS_REGION} \
                        --name ${EKS_CLUSTER}-dev
                    """
                    
                    // Create namespace if not exists
                    sh "kubectl create namespace ${NAMESPACE}-dev --dry-run=client -o yaml | kubectl apply -f -"
                    
                    // Deploy application
                    sh """
                        # Update image in deployment
                        sed -i 's|IMAGE_PLACEHOLDER|${DOCKER_IMAGE}:${DOCKER_TAG}|g' deployment.yml
                        
                        # Apply Kubernetes manifests
                        kubectl apply -f deployment.yml -n ${NAMESPACE}-dev
                        kubectl apply -f service.yml -n ${NAMESPACE}-dev
                        
                        # Wait for rollout
                        kubectl rollout status deployment/bms-app -n ${NAMESPACE}-dev --timeout=300s
                    """
                }
            }
        }
        
        // STAGE 9: Integration Tests
        stage('Integration Tests') {
            steps {
                script {
                    // Get LoadBalancer URL
                    sh '''
                        sleep 30  # Wait for service to be ready
                        SERVICE_URL=$(kubectl get svc bms-service -n ${NAMESPACE}-dev -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
                        echo "Testing application at: http://${SERVICE_URL}"
                        
                        # Run smoke tests
                        curl -f http://${SERVICE_URL}/api/health || exit 1
                        curl -f http://${SERVICE_URL}/api/movies || echo "Movies endpoint might need database"
                    '''
                }
            }
        }
        
        // STAGE 10: Deploy to Production (Manual Approval)
        stage('Approval for Production') {
            steps {
                timeout(time: 2, unit: 'HOURS') {
                    input message: 'Deploy to production?', ok: 'Deploy'
                }
            }
        }
        
        // STAGE 11: Deploy to Production
        stage('Deploy to Production') {
            steps {
                script {
                    // Switch to production cluster
                    sh """
                        aws eks update-kubeconfig \
                        --region ${AWS_REGION} \
                        --name ${EKS_CLUSTER}-prod
                    """
                    
                    // Create production namespace
                    sh "kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -"
                    
                    // Deploy with production config
                    sh """
                        # Use the same image for production
                        kubectl apply -f deployment.yml -n ${NAMESPACE}
                        kubectl apply -f service.yml -n ${NAMESPACE}
                        kubectl apply -f ingress.yml -n ${NAMESPACE}
                        
                        # Wait for rollout
                        kubectl rollout status deployment/bms-app -n ${NAMESPACE} --timeout=300s
                        
                        echo "Production deployment complete!"
                        echo "Application URL: https://bookmyshow.yourdomain.com"
                    """
                }
            }
        }
        
        // STAGE 12: Monitoring Setup
        stage('Setup Monitoring') {
            steps {
                script {
                    sh '''
                        # Deploy Prometheus
                        kubectl apply -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/main/manifests/setup
                        kubectl apply -f https://raw.githubusercontent.com/prometheus-operator/kube-prometheus/main/manifests/
                        
                        # Deploy Grafana
                        kubectl apply -f monitoring/grafana-dashboard.yaml
                        
                        echo "Monitoring deployed!"
                        echo "Grafana URL: http://grafana.${NAMESPACE}.svc.cluster.local:3000"
                    '''
                }
            }
        }
    }
    
    post {
        success {
            echo 'Pipeline completed successfully!'
            emailext (
                subject: "SUCCESS: BookMyShow Deployment #${BUILD_NUMBER}",
                body: "The deployment completed successfully.\nBuild: ${BUILD_NUMBER}\nURL: https://bookmyshow.yourdomain.com",
                to: 'devops-team@yourcompany.com'
            )
        }
        failure {
            echo 'Pipeline failed!'
            emailext (
                subject: "FAILURE: BookMyShow Deployment #${BUILD_NUMBER}",
                body: "The deployment failed. Please check Jenkins logs.\nBuild: ${BUILD_NUMBER}",
                to: 'devops-team@yourcompany.com'
            )
        }
        always {
            // Cleanup
            sh 'docker system prune -f'
            echo 'Pipeline completed'
        }
    }
}
